 * Features:
 *  - FSM: WAITING -> SIGNAL -> JAMMED -> DISPLAY -> WAITING
 *  - Random signal timing (HAL RNG)
 *  - Debounced START/STOP buttons
 *  - LCD status + reaction/penalty time
 *  - LEDs: GREEN on signal; RED on jam/penalty
 */

#include "stm32f4xx_hal.h"
#include <stdbool.h>
#include <stdio.h>

/* -------- Pin/Periph bindings (adjust to your CubeMX setup) -------- */
#define BTN_START_GPIO     GPIOA
#define BTN_START_PIN      GPIO_PIN_0
#define BTN_STOP_GPIO      GPIOA
#define BTN_STOP_PIN       GPIO_PIN_1
#define LED_GREEN_GPIO     GPIOB
#define LED_GREEN_PIN      GPIO_PIN_0
#define LED_RED_GPIO       GPIOB
#define LED_RED_PIN        GPIO_PIN_7

extern RNG_HandleTypeDef hrng;     // from CubeMX
extern TIM_HandleTypeDef htim2;    // 1 kHz timebase (1 ms tick)

/* ----------------------------- LCD stubs ---------------------------- */
/* Replace with your HD44780/STM32 LCD driver calls */
static void lcd_init(void) { /* lcd_hw_init(); lcd_clear(); */ }
static void lcd_clear(void) {}
static void lcd_set_cursor(uint8_t r, uint8_t c) { (void)r; (void)c; }
static void lcd_printf(const char *s) { (void)s; }

/* --------------------------- Utilities ------------------------------ */
static inline void led_green(bool on){ HAL_GPIO_WritePin(LED_GREEN_GPIO, LED_GREEN_PIN, on?GPIO_PIN_SET:GPIO_PIN_RESET); }
static inline void led_red  (bool on){ HAL_GPIO_WritePin(LED_RED_GPIO,   LED_RED_PIN,   on?GPIO_PIN_SET:GPIO_PIN_RESET); }

static bool read_btn(GPIO_TypeDef* port, uint16_t pin){
    return HAL_GPIO_ReadPin(port, pin) == GPIO_PIN_SET;
}

static bool debounce(GPIO_TypeDef* port, uint16_t pin, uint32_t ms, uint32_t now){
    const uint32_t end = now + ms;
    uint8_t stable = 0;
    while ((int32_t)(end - __HAL_TIM_GET_COUNTER(&htim2)) > 0){
        if (read_btn(port, pin)) { if (++stable > 3) return true; }
        else stable = 0;
        HAL_Delay(1);
    }
    return false;
}

static uint32_t now_ms(void){ return __HAL_TIM_GET_COUNTER(&htim2); }

/* Random delay in ms between [min,max] */
static uint32_t rnd_ms(uint32_t min_ms, uint32_t max_ms){
    uint32_t r = 0;
    HAL_RNG_GenerateRandomNumber(&hrng, &r);
    if (max_ms <= min_ms) return min_ms;
    return min_ms + (r % (max_ms - min_ms + 1));
}

/* -------------------------- FSM Definition -------------------------- */
typedef enum {
    WAITING = 0,
    SIGNAL,
    JAMMED,
    DISPLAY
} state_t;

int main(void)
{
    HAL_Init();
    SystemClock_Config();     // generated by CubeMX
    MX_GPIO_Init();           // includes pins above
    MX_RNG_Init();
    MX_TIM2_Init();           // configured 1 kHz up-counter
    HAL_TIM_Base_Start(&htim2);

    lcd_init();
    lcd_clear();
    led_green(false);
    led_red(false);

    state_t state = WAITING;
    uint32_t t_start = 0, t_signal = 0, t_stop = 0;
    uint32_t delay_ms = 0;
    char line[32];

    while (1){
        switch (state){
        case WAITING:
            lcd_clear();
            lcd_set_cursor(0,0); lcd_printf("Press START");
            lcd_set_cursor(1,0); lcd_printf("Await signal...");
            led_green(false); led_red(false);

            /* Wait for stable START press */
            if (debounce(BTN_START_GPIO, BTN_START_PIN, 20, now_ms())){
                /* Schedule signal */
                delay_ms = rnd_ms(1200, 3500);
                t_start = now_ms();
                state = SIGNAL;
            }
            break;

        case SIGNAL: {
            /* If user jumps the gun -> JAMMED */
            if (read_btn(BTN_STOP_GPIO, BTN_STOP_PIN)){
                state = JAMMED;
                break;
            }
            if ((int32_t)(now_ms() - t_start) >= (int32_t)delay_ms){
                /* Raise signal */
                led_green(true);
                lcd_clear();
                lcd_set_cursor(0,0); lcd_printf("SIGNAL! Press STOP");
                t_signal = now_ms();

                /* Wait for STOP press (debounced) */
                while (!debounce(BTN_STOP_GPIO, BTN_STOP_PIN, 10, now_ms())) {
                    /* keep checking */
                }
                t_stop = now_ms();
                state = DISPLAY;
            }
            break;
        }

        case JAMMED: {
            /* Early press penalty */
            led_green(false); led_red(true);
            lcd_clear();
            lcd_set_cursor(0,0); lcd_printf("JAM DETECTED");
            lcd_set_cursor(1,0); lcd_printf("Penalty +500 ms");
            HAL_Delay(1200);
            led_red(false);
            state = WAITING;
            break;
        }

        case DISPLAY: {
            led_green(false);
            uint32_t reaction = t_stop - t_signal;
            snprintf(line, sizeof(line), "Reaction: %lums", (unsigned long)reaction);
            lcd_clear();
            lcd_set_cursor(0,0); lcd_printf(line);
            lcd_set_cursor(1,0); lcd_printf("Press START");
            HAL_Delay(1500);
            state = WAITING;
            break;
        }

        default: state = WAITING; break;
        }
        HAL_Delay(5); /* cooperative pacing */
    }
}